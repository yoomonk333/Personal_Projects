# -*- coding: utf-8 -*-
"""lab3 umang.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_DiWpL1KFTEzYa0Ptu9BlHk2ScYVRWgY

# Lab 3 Artificiall Intelligence I

# Python and libraries


**Deadline**: September 26-Group-A, September 29, Group-B (mid-night)



You will need to use numpy and PyTorch documentations for this assignment:

* https://docs.scipy.org/doc/numpy/reference/
* https://pytorch.org/docs/stable/torch.html

You can also reference Python API documentations freely.


### What to submit

Submit a PDF file containing all your code, outputs, and write-up
from parts 1-5. You can produce a PDF of your Google Colab file by
going to **File > Print** and then save as PDF. The Colab instructions
has more information.Submit using blackboard in the Lab3 folder please.

**Do not submit any other files produced by your code.**

Include a link to your colab file in your submission.

Please use Google Colab to complete this assignment. If you want to use Jupyter Notebook, please complete the assignment and upload your Jupyter Notebook file to Google Colab for submission. 

With Colab, you can export a PDF file using the menu option
`File -> Print` and save as PDF file.

## Colab Link

Submit make sure to include a link to your colab file here

Colab Link: https://colab.research.google.com/drive/1_DiWpL1KFTEzYa0Ptu9BlHk2ScYVRWgY

## Part 0. Environment Setup; Readings

Please refer to Colab instructions https://colab.research.google.com/drive/1YKHHLSlG-B9Ez2-zf-YFxXTVgfC_Aqtt

## Part 1. Python Basics 

The purpose of this section is to get you used to the 
basics of Python, including working with functions, numbers,
lists, and strings.

### Part (a) 

Write a function `sum_of_cubes` that computes the sum of cubes up to `n`. If the input to `sum_of_cubes` invalid (e.g. negative or non-integer `n`), the function should print out `"Invalid input"` and return `-1`.
"""

def sum_of_cubes(n):
  if (n<0):
    print("Invalid Number") 
    return -1
  else:
    return sum(x**3 for x in range(1, n+1))

sum_of_cubes(3)

"""### Part (b) 

Write a function `word_lengths` that takes a sentence (string), computes the length of each word in that sentence, and returns the length of each word in a list. You can
assume that words are always separated by a space character `" "`.

Hint: recall the `str.split` function in Python.
If you arenot sure how this function works, try
typing `help(str.split)` into a Python shell, or check out https://docs.python.org/3.6/library/stdtypes.html#str.split
"""

help(str.split)

def words_lengths(sentence):
  
  num_of_words = sentence.split()
  length = []
  for word in num_of_words:
   
    length.append(len(word))
    print(word,length)
   
  return length
    
words_lengths("Hello Python")

"""### Part (c) 

Write a function `all_same_length` that takes a sentence (string),
and checks whether every word in the string is the same length.
You should call the function `word_lengths` in the body
of this new function.
"""

def all_same_length(sentence):
  
  words = words_lengths(sentence)
  _size = len(words)
  
  for x in range(_size):
    
    y = x + 1
    
    for z in range(y, _size):
      
      if words[x] != words[z]:
        
        return -1
        print("No same length")
        break
      
      elif words[x] == words[z]:
        
        print("Same length")
        
      
        
    
all_same_length("Hello Python")

"""## Part 2. NumPy Exercises 

In this part of the lab, you'll be manipulating arrays 
usign NumPy. Normally, we use the shorter name `np` to represent
the package `numpy`.
"""

import numpy as np

"""### Part (a) 

The below variables `matrix` and `vector` are numpy arrays. Explain what you think `<NumpyArray>.size` and `<NumpyArray>.shape` represent.
"""

matrix = np.array([[1., 2., 3., 0.5],
                   [4., 5., 0., 0.],
                   [-1., -2., 1., 1.]])
vector = np.array([2., 0., 1., -2.])

matrix.size

"""It tells about the size of matrix which resembles the number of elements in the matrix"""

matrix.shape

"""matrix.shape displays the number of rows and columns of the matrix in the above example: Rows = 3, Columns = 4"""

vector.size

"""It tells about the size of matrix which resembles the number of elements in the matrix"""

vector.shape

"""vector.shape displays the number of rows and columns of the matrix in the above example: Rows = 4 , Columns = 0

### Part (c) 

Perform matrix multiplication `output = matrix x vector` by using
for loops to iterate through the columns and rows.
Do not use any builtin NumPy functions.
Cast your output into a NumPy array, if it isn't one already.

Hint: be mindful of the dimension of output
"""

import numpy as np

matrix = np.array([[1., 2., 3., 0.5],
                   [4., 5., 0., 0.],
                   [-1., -2., 1., 1.]])
vector = np.array([2., 0., 1., -2.])

output=np.array([0,0,0])



for i in range(3):
  #for j in len(range(vector)):
  for j in range(4):
    
    
    output[i] += matrix[i][j] * vector[j]
   
print(output)

output

"""### Part (d) 

Perform matrix multiplication `output2 = matrix x vector` by using
the function `numpy.dot`.

We will never actually write code as in
part(c), not only because `numpy.dot` is more concise and easier to read/write, but also performance-wise `numpy.dot` is much faster (it is written in C and highly optimized).
In general, we will avoid for loops in our code.
"""

output_2 = np.dot(matrix,vector)
print(output_2)

"""### Part (e) 

As a way to test for consistency, show that the two outputs match.
"""

import numpy as np


if (np.array_equal(output, output_2)):
  
  print("Outputs are same")
  
else:
  
  print("Outputs are not same")

"""### Part (f) -- 3pt

Show that using `np.dot` is faster than using your code from part (c).

You may find the below code snippit helpful:
"""

import time
import numpy as np


start_time = time.time()

output_2 = np.dot(matrix,vector)

    
# record the time after the code is run
end_time = time.time()

# compute the difference
diff1 = end_time - start_time

print(diff1)


# record the time before running code
start_time = time.time()

for i in range(3):
  for j in range(4):
    
    
    output[i] += matrix[i][j] * vector[j]
    


    
# record the time after the code is run
end_time = time.time()

# compute the difference
diff2 = end_time - start_time
print(diff2)



"""## Part 3. Callable Objects

A *callable object* is any object that can be called like a function.
In Python, any object whose class has a `__call__` method will be callable. 
For example, we can define an `AddBias` class that is initialized with a value `val`. When the object of the Adder class is called with `input`, it will return the sum of `val` and `input`:
"""

class AddBias(object):       # this is a new class AddBias, which inherits from the class `object`
    def __init__(self, val): # this is the object constructor
        self.val = val
    def __call__(self, input):
        return self.val + input # `self` is like `this` in many languages

add4 = AddBias(4)
add4(3)

# AddBias works with numpy arrays as well

add1 = AddBias(1)
add1(np.array([3,4,5]))

"""### Part (a)

Create a callable object class `ElementwiseMultiply` that is initialized with `weight`, which is a numpy array (with 1-dimension). 
When called on `input` of **the same shape** as `weight`, the object will output an elementwise product of `input` and `weight`. For example, the 1st element in the output will be a product of the first element of `input` and first element of `weight`. If the `input` and `weight` have different shape, do not return anything.
"""

import numpy as np

class ElementwiseMultiply(object):
  def __init__(self, weight):
    self.weight = weight
    
  def __call__(self, input):
    self.input = input
    
    if(len(weight)==len(input)):
      return (weight*input)
    
    else:
      return -1
    
weight=np.array([2, 3, 4])
input=np.array([4, 3, 4])
multiply = ElementwiseMultiply(weight)
multiply(input)

"""### Part (b)

Create a callable object class `LeakyRelu` that is initialized
with `alpha`, which is a scalar value. 
When called on input `x`, which may be a NumPy array, 
the object will output:

* $x$ if $x \ge 0$
* $\alpha x$ if $x < 0$

For example,

```
>>> leaky_relu = LeakyRelu(0.1)
>>> leaky_relu(1)
1
>>> leaky_relu(-1)
-0.1
>>> x = np.array([1, -1])
>>> leaky_relu(x)
np.array([1, -0.1])
```

To obtain full marks, do **not** use any for-loops to implement this class.
"""

class LeakyRelu():
  
  def __init__(self, alpha):
    self.alpha = alpha
    print('inside init')
    
  def __call__(self, x):
    self.x = x
    print('inside call')
    
    if ((isinstance(x,int))):
    
      if (x >= 0):
        return x
      
      else:
        return self.alpha*self.x
      
    elif (isinstance(x,np.ndarray)):
      if all(x>0):
        return x
      
      elif any(x<0):
        return self.alpha*self.x
        
      
    else:
      return 0
      
obj = LeakyRelu(2)
obj(np.array([10,20,100]))

"""**bold text**### Part (c)

Run the below code and include the output in your report.
"""

weight_1 = np.array([1, 2, 3, 4.])
weight_2 = np.array([-1, -2, -3, -4.])
bias_1 = 3.0
bias_2 = -2.0
alpha = 0.1

elem_mult_1 = ElementwiseMultiply(weight_1)
add_bias_1 = AddBias(bias_1)
leaky_relu = LeakyRelu(alpha)
elem_mult_2 = ElementwiseMultiply(weight_2)
add_bias_2 = AddBias(bias_2)
layers = Compose([elem_mult_1, 
                  add_bias_1, 
                  leaky_relu,
                  elem_mult_2, 
                  add_bias_2, 
                  leaky_relu])

input = np.array([10, 5, -5, -10.])
print("Input: ", input)

output = layers(input)
print("Output:", output)

"""## Part 4. Images 

A picture or image can be represented as a NumPy array of “pixels”, 
with dimensions H × W × C, where H is the height of the image, W is the width of the image,
and C is the number of colour channels. Typically we will use an image with channels that give the the Red, Green, and Blue “level” of each pixel, which is referred to with the short form RGB.

You will write Python code to load an image, and perform several array manipulations to the image and visualize their effects.
"""

import matplotlib.pyplot as plt

"""### Part (a) 

This is a photograph of a dog whose name is Mochi.

![alt text](https://drive.google.com/uc?export=view&id=1oaLVR2hr1_qzpKQ47i9rVUIklwbDcews)

Load the image from its url (https://drive.google.com/uc?export=view&id=1oaLVR2hr1_qzpKQ47i9rVUIklwbDcews) into the variable `img` using the `plt.imread` function.

Hint: You can enter the URL directly into the `plt.imread` function as a Python string.

Hint: image can be uploaded from the system using the code below
"""

import matplotlib.pyplot as plt 

img = plt.imread('https://drive.google.com/uc?export=view&id=1oaLVR2hr1_qzpKQ47i9rVUIklwbDcews')
print(img)
print(plt.imshow(img))



"""### Part (b) 

Use the function `plt.imshow` to visualize `img`. 

This function will also show the coordinate system used to identify pixels.
The origin is at the top left corner, and the first dimension indicates the Y (row) direction, 
and the second dimension indicates the X (column) dimension.
"""

print(plt.imshow(img))

"""### Part (c) 

Modify the image by adding a constant value of 0.25 to each pixel in the `img` and
store the result in the variable `img_add`. Note that, since the range for the pixels 
needs to be between [0, 1], you will also need to clip img_add to be in the range [0, 1] 
using `numpy.clip`. Clipping sets any value that is outside of the desired range to the 
closest endpoint. Display the image using `plt.imshow`.
"""

import numpy as np
new = np.array(img)
for pixel in new:
  pixel += 0.25
img_add = np.clip(new, a_min = 0, a_max = 1)
print(img_add)
plt.imshow(img_add)

"""### Part (d)

Crop the **original** image (`img` variable) to a 130 x 150 image including Mochi's face. Discard the alpha colour channel (i.e. resulting `img_cropped` should **only have RGB channels**)

Display the image.
"""

crop_img = img[5:130, 5:150]
new_img= crop_img
print(plt.imshow(new_img))

"""## Part 5. Basics of PyTorch ]

PyTorch is a Python-based neural networks package. Along with tensorflow, PyTorch is currently one of the most popular machine learning libraries.

PyTorch, at its core, is similar to Numpy in a sense that they both 
try to make it easier to write codes for scientific computing
achieve improved performance over vanilla Python by leveraging highly optimized C back-end.
However, compare to Numpy, PyTorch offers much better GPU support and provides many high-level features for machine learning. Technically, Numpy can be used to perform almost every thing PyTorch does. However, Numpy would be a lot slower than PyTorch, especially with CUDA GPU, and it would take more effort to write machine learning related code compared to using PyTorch.
"""

import torch

"""### Part (a) 

Use the function `torch.from_numpy` to convert the numpy array `img_cropped` into
a PyTorch tensor. Save the result in a variable called `img_torch`.
"""

import torch


img_torch = torch.from_numpy(new_img)
print(plt.imshow(img_torch))

"""### Part (b) 

Use the method `<Tensor>.shape` to find the shape (dimension and size) of `img_torch`.
"""

print(img_torch.size)

print(img_torch.shape)

print(img_torch.ndim)

"""### Part (c) 

How many floating-point numbers are stored in the tensor `img_torch`?
"""



"""### Part (d) 

What does the code `img_torch.transpose(0,2)` do? What does the expression return? 
Is the original variable `img_torch` updated? Explain.
"""

print(img_torch.transpose(0,2))

"""### Part (e) 

What does the code `img_torch.unsqueeze(0)` do? What does the expression return? 
Is the original variable `img_torch` updated? Explain.
"""

img_torch.unsqueeze(0)

"""### Part (f) 

Find the maximum value of `img_torch` along each colour channel? Your output should be a one-dimensional
PyTorch tensor with exactly three values.

Hint: lookup the function `torch.max`.
"""

